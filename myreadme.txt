h1.Interacting with Entity Manager

Doctrine provides both the models and the work of persisting data, or practically speaking, what interface do we use? Doctrine's Entity Manager is the answer, which handles the persistence of entities, including the storage and retrieval of records within the database. Within the controller, the entity manager is accessed via a shortcut to the Doctrine service. It's easy to just assign it into a variable like em equals this for the controller, get Doctrine for the Doctrine registry service, then get manager to get the Entity Manager.

The Entity Manager itself has a number of common methods. Persist which takes an argument of an entity object makes an entity instance managed by Doctrine em persist in the database. Basically, it's telling Doctrine that changes will occur. It's also possible to remove an entity as well, which will mark it as ready to be deleted. Both persist and remove must prepare with flush which will actually execute the queries against the database. Practically speaking, flush synchronizes changes between the memory and the database.

The Entity Manager doesn't directly get entities. Instead, Doctrine provides repositories which does the work of fetching entities of a certain class. The resulting entities can be persisted through the Entity Manager if there's a need to make changes. Within the controller, repositories can be accessed through the Entity Manager using the get repository method which takes an argument containing the string naming the bundle and entity. This is the same format we used when generating the controller, and that's no coincidence.

Repositories have a number of commonly used methods as well such as find which takes an ID to get an entity of a certain class by ID and find all which gets all entities of that class. Now that we've got some contacts about how we can interact with Doctrine, let's take a look at the generated controllers to see how they work. Switch to the IDE. Within source, open up the controller folder. There are two new files in here. The issue controller and the publication controller.

Let's take a look at publication. At the top of the file, the name space is declared. A Lynda magazine bundle controller. Same as the default controller. The imports are similar as well except towards the bottom. The publication entity which we created earlier and the form for the publication type. Now, that's new. We're going to be exploring forms the next chapter so let's skip it for now. Moving down, the index action is our first exposure to Doctrine. The route slash publication maps to what we saw in the browser.

There's actually three statements in here. The first assigns em to an instance of the Entity Manager. The second statement assigns the variable entities to a change command, getting the repositories for the publication within the Lynda magazine bundle, then find all to the publication entities. The third and last statement sends data view template. One key entities containing, well, the entities. Wait, that's it? Yup, this is an extremely thin controller. Let's take a look at the associated template.

Open resources to get the views. There are two new folders here. Issue and publication and each is named after the controller. Within publication, there are four templates. Edit, index, new, and show. Let's take a peek at index. We're going to learn a lot more about Twig templates after we dive in the forms but honestly, this is pretty much straight HTML with a little additional markup. There's a header the says publication list that a table that loops through entities.

The first cell prints the path to publication show. The next cell prints the name of the entity. There are links to show and edit. That's it for the for loop. At the bottom, there's a link to create a new entry. This is complete separation of design and logic. Close the index template. Back in the publication controller, let's take a look at create action. We have that there's a different method post, and that a template is explicitly defined using the bundle name, entity name, then the name of the file.

The method takes an argument of an instance of request as we need access to use our import. The method itself starts of the new entity of type publication, then a form. We'll be covering forms in just a moment. But just reading through it, a new form is creating with the structure of an entity. On the next line, the form receives the request, the user input. If the form validates, then the Entity Managers retrieve, the entity is persistent and flushed. When complete, a redirection takes place which will redirect the browser to a new location which is publication show with the ID of the newly persisted entity.

Otherwise, both the entity and form are sent to the view. For comparison, let's look at the show action. The route puts ID in brackets, which if we look at the show action argument, is the same name and is populated by whatever the user specifies in the path. Within the method, again the Entity Manager is instantiated. Then on the next line, an entity is populated using the find method. But the entity isn't found, an exception is thrown. Otherwise, both the entity and the delete form are sent to the view. In this chapter, we've been exploring how to model magazines in the database.

We introduced both Doctrine and object-relational mapping, including features and comparisons to propel. Then we modeled a magazine by generating an entity, then customize the newly created entities and generated database tables for persistence storage. We established one to many and many to one associations between entities. With that foundation, we used Doctrine to generate the magazine controllers, both publication and issue. Other than controllers, we created, edited, and debugged issues with entities, including discovering the debugged toolbar.

Finally, we interacted with Doctrine's Entity Manager and repositories, along with common methods such as persist and flush. Towards the end of this chapter, we've been seeing a lot of examples of the use of forms. How do we actually use them and customize them to our needs?

