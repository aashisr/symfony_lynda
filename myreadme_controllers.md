Building a Response with a Controller
======================================
The life cycle of a Symfony request
--------------------------------------
 [Voiceover] In this chapter, we're going to start writing custom code to build a page but before we can do that we need to understand: How Symfony handles requests from a client? That way we'll know the why, not just the how, of Symfony development. HTTP transactions are made up of two actions: a request, and a response. A client, such as a web browser, sends a request to a server. A request is literally a plain text message containing context about what information is desired. These requests are sent to a server and the browser waits for the response.

Once the response is received the browser renders the response. On the other side, the server interprets the request and builds a response from the context of the request that's sent back to the client. The contents of the response can be in any arbitrary formats such as HTML, XML, JSON, and so forth. Symfony2 uses the core component HttpFoundation to handle these requests and build the response. HttpFoundation is an object-oriented layer for the HTTP specification which replaces the default PHP global variables and functions.

There are two classes within HttpFoundation. The first class is Request which give context about what was requested and how. Practically speaking, we'll be using the Request class to retrieve user input. The Request class gives access to information about the client request through properties such as the request, query, cookies, files, headers, along with some others. Each property is an instance of a "ParameterBag" which contains common helper methods such as get, add, set, remove, and so forth.

Additionally a developer can filter input values to look for something specific. That's a lot more convenient than PHP's built in globals. By taking an object-oriented approach it's easy to simulate requests for testing by creating a new instance rather than trying to mess around with globals. The second HttpFoundation class is the Response which is used to build an HTTP response message to be returned to the client. The response includes content such as the body of a page and HTTP status code like 200 or 404 and so forth, headers such as the format of the response, and the ability to actually send the fully constructed response back to the client.

Practically speaking, we'll be building custom code that sends response objects back to the client. Sitting on top of the HttpFoundation is the HttpKernel class. The Kernel standardizes how to handle client requests in a very lightweight manner. The Kernel's responsibility is to convert a request object into a response object. Like any good manager it delegates by using controllers which do the actual work. Controllers are in the purest sense any valid PHP callable function or construct.

With that said, Symfony provides a whole structure for controllers which we'll be exploring. The Kernels also wear plugins and additional tools can be added to the application. Knowing what to do with the request is up to the routing component. A router determines which controller should be used to fulfill the request based on information within the request and whatever configuration has been defined within the application. This means the routing controller maps a URL path to a controller. For example, a request to /blog can be responded to using code within the blog controller.

So how does Symfony know what to do with the request? As previously mentioned, in Symfony, all requests start with front controller such as app.php. The front controller sends the request to the Symfony2 Kernel which passes the request to the router. The router determines which controller will be used and the controller then creates and returns the response object. Fortunately most of this work takes place transparently. So all we need to focus on is to finding the custom functionality. With this context two things are needed at a bare minimum to create a page in Symfony.

First, a route needs to be defined to map a URL such as /index or about to a controller that will be executed then of course we'll actually need to create the controller to take the incoming request and build a response object to be returned. Sounds pretty straightforward to me. But where to we put the custom code for the page?

Creating first bundle with the Console
---------------------------------------
- To create a page, we're going to have to write some custom code and have a place to put it. A bundle organizes custom code in Symfony. Bundle is basically a directory that contains anything that relates to a feature. This includes PHP files, templates, configuration, tests and even assets like CSS style sheets and JavaScript. Bundles have a specific structure that ensure interoperability but with that said, the structure is easy to follow and can be generated automatically. Do this structure and atomic design, bundles can be shared between projects such as publishing them as open source which is a fantastic way to solve common problems.

Bundles are organized with PHP namespaces using the PHP autoloading standard, PSR-0 so Symfony knows how to access the contents without using require or include statements. If you're not familiar with this standard, I recommend checking out php dash fig dot org. Each bundle name must begin with a vendor segment followed by an optional category segment, a namespace short name that has semantic meaning about what the bundle does and then must end with the suffix "bundle".

To learn more about bundle naming, check out the Symfony cookbook for best practices. With that context, let's define the bundle name for our application. The vendor should define the organization, group or individual. In my case, it's the organization Lynda dot com so I'll just use "Lynda". The category allows for additional levels of hierarchy and is optional so let's just skip it for now and leave it blank. The namespace, on the other hand, is by far the most important and should have semantic meaning regarding the functionality being defined.

I'm encapsulating all the logic for the magazine cataloging application in this bundle so the name "Magazine" is most logical. Therefore, the bundle name using this data is "LyndaMagazineBundle" because all bundles must end with the suffix "bundle". How do we create a bundle? Symfony can create a bundle from the command line console. Let's switch the terminal. First we need to change directory to wherever we installed Symfony. I made a cd to, in my case, slash media sf underscore sandbox Symfony.

We're going to use Symfony's console to generate the code. We can invoke the console and see what commands are available by typing php space app slash console. Scrolling up to the top, I can see general usage commands along with options and available commands for every component and bundle. One of the entries is "generate bundle", which will generate a bundle. To learn more about command, use the Help option. For example, php space app slash console space generate colon bundle space dash dash help.

The console provides built-in documentation in use cases and provides us with documentation such as noting that the bundle name space must end with "bundle". Let's generate the bundle for the magazine. Start once again with php space app slash console generate colon bundle space, and then the option dash dash namespace equals. We'll start with Lynda, the vendor with a capital L, then slash as the namespace limiter then the bundle name, "magazine" and then remember it must end with "bundle".

Press "Enter", this will start a wizard. The bundle name is generated automatically based on the namespace so press "Enter" to confirm. The bundle itself can be generated anywhere but the suggested default makes sense and uses the standard conventions so just press "Enter". A number of different configuration formats are supported. Let's use "annotation", which I'll discuss in much more detail in just a moment. We'll also be asked if we want code snippets to be generated on our behalf. Yes, actually, because that will be very helpful and will give us a template on which we can build more on.

Do we confirm? Review what was created and make sure it's correct. If so, press "Enter" for yes. Symfony will generate the structure then ask if we want to update the kernel to load the new code. Say yes so the kernel knows that the magazine bundle exists. Also, say yes to updating the routing which will allow URL's to be translated. That was a lot of questions but now the code can be used. Let's take a look at was generated. Switch to an IDE. Open up the source directory. Instead of being empty, there's a new directory in here called "Lynda".

If I open it up, I can see the magazine bundle. We must go deeper. Open it up. This is a bit more logical, four directories and a single PHP file. Let's take a quick look at the file, the PHP file, Lynda magazine bundle contains a placeholder for optionally extending the bundle class itself which we don't need to do. It can be safely closed. Now we created the bundle so we had a place for the controller and there's a nice folder named "Controller". Sounds promising, doesn't it?

The anatomy of a Controller
-------------------------------
- In Symfony, controllers are responsible for generating a response to a request. There's a couple different ways of producing response. One way is to directly return a response object, but this leads to a very slippery slope of mixing business logic with presentation. That's typically a bad thing. Therefore, whenever possible it's preferable to render the data with a view. This separates the logic from the presentation. Controllers contain what are known as actions, which are methods within the controller class. Actions should be atomic as possible, meaning each action should do only one thing.

It's perfectly acceptable to perform an action and redirect to another if another operation is required. Actions are named after verbs that define a user behavior, such as list, update, delete, and so forth. Action names are in lowerCamelCase notation, so start with a lowercase letter and make sure that it ends with a suffix Action with a capital A. To extend on the previous example, the complete name would be listAction, updateAction and deleteAction.

Let's explore what an actual controller looks like by switching back to the IDE. Let's open up the controller folder. There's one file in here, defaultController. This is a very simple example of a controller. Note the namespace, the vendor Linda, followed by the name of the bundle, MagazineBundle, and then controller. Underneath the controller imports three other namespaces, the Symphony controller, and two Sensio configurations for route and template. These are for the annotation configuration, which we'll see in the docblock for the public function indexAction.

The default controller extends the base controller. We can see that by right-clicking, going to navigate, go to declaration. The base controller contains base methods with common features, such as being able to generate a URL, forward an action, redirect, and so forth. We can close the base controller and go back to the default controller. There's only one action in here, the indexAction. It takes one parameter, the name. The docblock contains annotations that actually define behavior, they're not just for show.

The route means anything matching the URL path hello followed by the variable name will be sent to this function indexAction. Template associates the controller with a template name for the view, which if left empty just assumes the template is named after the controller and the action. We're going to explore templates in just a moment. The contents of the action is, well there's not much here. Index just returns an array with one key, name with the value of name. This is a shorthanded notation for rendering a view. It's also possibly to explicitly render a specific view, which is useful when there are multiple ways to render a response, like HTML or XML.

Okay, so there's a template associated with the view. What is a template, what does it do, and where is it?

Delegating Presentation to a view template
--------------------------------------------
Integral to every view is a template. Templates are text files that are used to generate content in any text-based format like HTML, XML, CSV, and so forth. Templates are used by programs known as template engines or template processors that combine one or more templates with the data from a model and render the result. Template engines encourage code organization by separating design from logic and delegate responsibility such as modeling to developers and design to designers.

This reduces the overall amount of effort that is required to do work by minimizing duplication. There are couple of different kinds template engines for PHP and you've probably encountered PHP templates which are a mix of markup and executable PHP code. However, from a practical point of view, PHP templates are filled with problems. With great power comes great responsibility. It's incredibly easy to do very bad things in a PHP template. Not to say the designers don't know what they're doing but it's tempting an easy to mix business logic with presentation.

The end result can be slow, insecure, and difficult to maintain, especially if you're working with an inexperienced or unscrupulous team. Additionally, some designers may not be familiar with PHP, and that's just fine. Everybody has their specialty. The problem is when they get bound down trying to write code when all they want to do is build beautiful sites. They should have tools that are purpose-oriented without having to learn an entire programming language. Fortunately, there is an alternative. Twig is a template engine for PHP which is maintained by the same team that makes Symfony.

However, instead of PHP, Twig uses a much more concise and design-oriented approach to presentation. The end result is easier to read, more secure than allowing arbitrary PHP code, and much easier to work with than a PHP template. Twig is a powerful and feature-filled system, including a robust cashing system and inheritance and many other useful features. We'll explore some of Twig's feature later in the course and focus on practical application for now. There are three kinds of syntax in Twig.

First is do something, which is the single curly brace with a percent which executes statements like conditional logic and for loops. Here's an example. For each issue in collection of issues. There's also the say something syntax which is double curly braces which will print this route of variable or expression results. For example, this will print the contents of the variable issue dot name. The printing syntax also supports filters to transform the output. Filters are specified using a pipe than the name of the filter.

For example, the name of the issue can be displayed completely in uppercase. The final syntax is for comments. A curly brace and a hash tag. The results of a comment aren't displayed just like PHP comments. For example, nobody will ever know the extent of my collection of Hawaiian shirts. Within a bundle, Twig templates are stored in resources directory, in a sub-directory called views which helps reinforce the MVC structure to a less than subtle reminder. User typically organized by controller name in action which makes it easy to know which views are being use for what.

Twig template file names end in dot Twig so it's easy to anticipate the contents. Let's take a look at the view for a default controller by switching back to the IDE. Views live in resources in a sub-directory called views. Views are also organized by controller name so the views for the default controller are in, well, default. There's only one file in here. The template for the index action which ends in Twig. Open the file. Now, here's our print statements just the word hello.

Then, curly braces that contains the variable name. Is that everything? Well, let's see. Let's take a look at the whole thing in action. Switch to the browser. I'm going to navigate to HTTP, sandbox dot dev, Symfony slash web slash app underscore dev dot PHP slash hello. Okay, well we got a four of four because there wasn't a route to find for it. If you recall, the route was hello slash then a name. Alright, fine. Let's play by the route's rules.

Let's add slash John. Much better. It says, "Hello John!" Is that it? View the page source. In fact, yes, this is everything. Just the words hello John. Close the page source. Well, hello John isn't grammatically correct. How do we change that? Let's go back to the IDE. We'll start of by adding a comma after hello to make this a direct address. The result is talking to the viewer, not about the viewer. Not really a major change but the name is still in lowercase.

While the first may impulse might be to add capitalization in controller before passing the variable to the view, that's the wrong way to do it. That makes presentation logic with business logic. Instead, we can use Twig to make the change the variable using a filter. Filters are applied to variables using the pipe symbol, followed by the name of the filter. One of the filters is called capitalize, which capitalizes the first letter of a variable. Save, then return to the browser. Refresh the page.

Much better. We've changed how the data is presented and filtered the variable name. In this chapter, we've been exploring how to build the response to the controller which is touched on many parts within Symfony. We started by stepping through the life cycle of a Symfony request, including identifying the roles of a front controller, kernel, requests, and responses. We've then created a bundle to store our custom code using the Symfony console component. We dissected the anatomy of a controller down to the action. Then learn how to delegate presentation to view templates.

Coming up, we're going to model magazines in the database, and generate user interfaces to management which gives us a foundation to begin custom development.